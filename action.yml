name: "TypeScript CI/CD Pipeline"
description: "Complete CI/CD pipeline for TypeScript projects with optional release automation"
author: "spanscale"

branding:
  icon: "package"
  color: "blue"

inputs:
  node-version:
    description: "Node.js version to use"
    required: false
    default: "22.x"
  package-manager:
    description: "Package manager to use (npm or pnpm)"
    required: false
    default: "pnpm"
  pnpm-version:
    description: "pnpm version to use"
    required: false
    default: "10"
  working-directory:
    description: "Working directory for commands"
    required: false
    default: "."
  run-scripts:
    description: "Scripts to run (JSON array)"
    required: false
    default: '["install", "type-check", "lint", "build", "test"]'
  registry-url:
    description: "NPM registry URL"
    required: false
    default: "https://npm.pkg.github.com"
  registry-scope:
    description: "NPM registry scope"
    required: false
    default: "@spanscale"
  enable-release:
    description: "Enable release workflow after CI passes"
    required: false
    default: "false"
  release-bump-version:
    description: "Enable automatic version bumping"
    required: false
    default: "true"
  release-create-changelog:
    description: "Enable automatic changelog generation"
    required: false
    default: "true"
  release-comment-issues:
    description: "Enable commenting on related issues"
    required: false
    default: "false"
  release-publish-package:
    description: "Enable package publishing"
    required: false
    default: "false"
  release-type:
    description: "Release type for manual triggers (patch, minor, major, prepatch, preminor, premajor, prerelease)"
    required: false
    default: "patch"
  release-skip-rules:
    description: "Skip release if commit message contains these patterns (JSON array)"
    required: false
    default: '["[skip ci]", "[skip release]", "chore(release):"]'
  release-first-commit-bump:
    description: "Enable version bump on first commit (initial release)"
    required: false
    default: "false"
  release-version-patterns:
    description: "Custom patterns for version determination (JSON object)"
    required: false
    default: '{
      "[release:major]": "major",
      "[release:minor]": "minor", 
      "[release:patch]": "patch",
      "[release:premajor]": "premajor",
      "[release:preminor]": "preminor",
      "[release:prepatch]": "prepatch",
      "[release:prerelease]": "prerelease",
      "[release:v*]": "exact",
      "[release:stable]": "patch",
      "[major]": "major",
      "[minor]": "minor",
      "[patch]": "patch",
      "[hotfix]": "patch",
      "[urgent]": "patch",
      "[security]": "patch",
      "[breaking]": "major",
      "[feature]": "minor",
      "[beta]": "prepatch",
      "[alpha]": "preminor",
      "[rc]": "prerelease",
      "[stable]": "patch"
    }'
  release-create-tag:
    description: "Create git tag for the release"
    required: false
    default: "true"
  release-use-pr-patterns:
    description: "Use PR title for pattern detection when triggered by PR events"
    required: false
    default: "true"
  release-override-existing:
    description: "Override existing tags/releases if they exist (true/false)"
    required: false
    default: "false"
  package-name:
    description: "Package name for publishing (auto-detected from package.json if not specified)"
    required: false
    default: ""
  github-token:
    description: "GitHub token for authentication"
    required: true

outputs:
  version:
    description: "The new version number if a release was created"
    value: ${{ steps.version.outputs.version }}
  release-url:
    description: "URL of the created GitHub release"
    value: ${{ steps.release.outputs.url }}
  package-url:
    description: "URL of the published package"
    value: ${{ steps.publish.outputs.url }}

runs:
  using: "composite"
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        registry-url: ${{ inputs.registry-url }}
        scope: ${{ inputs.registry-scope }}
      env:
        NODE_AUTH_TOKEN: ${{ inputs.github-token }}
    
    - name: Setup pnpm
      if: ${{ inputs.package-manager == 'pnpm' }}
      uses: pnpm/action-setup@v2
      with:
        version: ${{ inputs.pnpm-version }}
        run_install: false
    
    - name: Run CI scripts
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        echo "Running CI pipeline..."
        
        # Determine package manager commands
        PM="${{ inputs.package-manager }}"
        echo "Using package manager: $PM"
        
        # Set package manager specific commands
        if [ "$PM" = "npm" ]; then
          INSTALL_CMD="npm ci"
          RUN_CMD="npm run"
        else
          INSTALL_CMD="pnpm install --frozen-lockfile"  
          RUN_CMD="pnpm"
        fi
        
        # Handle cases where GitHub Actions doesn't pass default values properly
        scripts='${{ inputs.run-scripts }}'
        
        # Debug output
        echo "Raw run-scripts value: '$scripts'"
        
        # Fallback to defaults if empty or not properly set
        if [[ -z "$scripts" || "$scripts" == "null" || "$scripts" == "" ]]; then
          echo "Using fallback default scripts"
          scripts='["install", "type-check", "lint", "build", "test"]'
        fi
        
        echo "Final scripts to execute: $scripts"
        
        # Execute each script
        echo "$scripts" | jq -r '.[]' | while read -r script; do
          if [[ -n "$script" && "$script" != "null" ]]; then
            if [ "$script" = "install" ]; then
              echo "▶ Running: $INSTALL_CMD"
              eval "$INSTALL_CMD"
            else
              echo "▶ Running: $RUN_CMD $script"
              eval "$RUN_CMD $script"
            fi
          fi
        done

    - name: Configure Git
      if: ${{ inputs.enable-release == 'true' }}
      shell: bash
      run: |
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git config --global user.name "github-actions[bot]"

    - name: Determine version bump
      if: ${{ inputs.enable-release == 'true' && inputs.release-bump-version == 'true' }}
      id: version
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        determine_bump_type() {
          local commit_msg="$1"
          local current_version="$2"
          
          case "$commit_msg" in
            *"[release:stable]"*)
              if echo "$commit_msg" | grep -q "BREAKING CHANGE\|!:"; then
                echo "major"
              elif echo "$commit_msg" | grep -q "^feat"; then
                echo "minor"
              else
                echo "patch"
              fi
              return ;;
            *"[release:premajor]"*) echo "premajor"; return ;;
            *"[release:preminor]"*) echo "preminor"; return ;;
            *"[release:prepatch]"*) echo "prepatch"; return ;;
          esac
          
          local is_prerelease=false
          if echo "$current_version" | grep -q "-"; then
            is_prerelease=true
          fi
          
          case "$commit_msg" in
            *"BREAKING CHANGE"*|*"!:"*)
              echo $($is_prerelease && echo "premajor" || echo "major") ;;
            "feat"*|"feat("*)
              echo $($is_prerelease && echo "preminor" || echo "minor") ;;
            "fix"*|"fix("*)
              echo $($is_prerelease && echo "prerelease" || echo "patch") ;;
            "docs"*|"test"*|"chore"*|"refactor"*|"perf"*|"ci"*|"style"*)
              echo $($is_prerelease && echo "prerelease" || echo "none") ;;
            *)
              echo "none" ;;
          esac
        }
        
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        
        # Determine message source for pattern detection
        if [ "${{ inputs.release-use-pr-patterns }}" = "true" ] && [ "${{ github.event_name }}" = "pull_request" ]; then
          # Use PR title for pattern detection
          COMMIT_MSG="${{ github.event.pull_request.title }}"
          echo "Using PR title for pattern detection: $COMMIT_MSG"
        else
          # Use commit message (default behavior)
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Using commit message for pattern detection"
        fi
        
        # Check if we should skip release based on rules
        echo "Checking skip rules..."
        SKIP_RULES='${{ inputs.release-skip-rules }}'
        echo "Skip rules: $SKIP_RULES"
        echo "Commit message: $COMMIT_MSG"
        
        # Check each skip rule (use literal string matching, not regex)
        while IFS= read -r rule; do
          if [[ "$COMMIT_MSG" == *"$rule"* ]]; then
            echo "Skipping release: commit message contains skip rule '$rule'"
            echo "version=" >> $GITHUB_OUTPUT
            exit 0
          fi
        done < <(echo "$SKIP_RULES" | jq -r '.[]')
        
        echo "No skip rules matched, proceeding with version determination"
        
        # Check if this is the first release
        IS_FIRST_RELEASE=false
        if ! git describe --tags --abbrev=0 2>/dev/null; then
          IS_FIRST_RELEASE=true
          echo "First release detected"
          if [ "${{ inputs.release-first-commit-bump }}" = "false" ]; then
            echo "First commit detected, skipping version bump but creating release with current version (release-first-commit-bump=false)"
            echo "Using current version from package.json: $CURRENT_VERSION"
            echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "Skipping all pattern matching and version bumping for first release"
            # Exit early, let the changelog generation and release process continue
            exit 0
          fi
        fi
        
        # Check custom version patterns (only if not first release with bump disabled)
        echo "Checking custom version patterns..."
        VERSION_PATTERNS='${{ inputs.release-version-patterns }}'
        echo "Version patterns: $VERSION_PATTERNS"
        
        CUSTOM_PATTERN_MATCHED=false
        
        # First, check for exact version patterns (highest priority)
        EXACT_VERSION=$(echo "$COMMIT_MSG" | grep -oE '\[release:v[0-9]+\.[0-9]+\.[0-9]+\]' | sed 's/\[release:v//;s/\]//')
        if [[ -n "$EXACT_VERSION" ]]; then
          echo "Custom pattern matched: [release:v$EXACT_VERSION] → exact"
          echo "Setting exact version: $EXACT_VERSION"
          npm version "$EXACT_VERSION" --no-git-tag-version --force
          NEW_VERSION="$EXACT_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"
          CUSTOM_PATTERN_MATCHED=true
        else
          # If no exact version, check other patterns
          for pattern in $(echo "$VERSION_PATTERNS" | jq -r 'keys[]'); do
            # Skip the exact version pattern as we already checked it
            if [[ "$pattern" == "[release:v*]" ]]; then
              continue
            fi
            
            if echo "$COMMIT_MSG" | grep -q "$pattern"; then
              ACTION=$(echo "$VERSION_PATTERNS" | jq -r --arg p "$pattern" '.[$p]')
              echo "Custom pattern matched: $pattern → $ACTION"
              BUMP_TYPE="$ACTION"
              CUSTOM_PATTERN_MATCHED=true
              break
            fi
          done
        fi
        
        # If no custom pattern matched, use standard logic
        if [ "$CUSTOM_PATTERN_MATCHED" = "false" ]; then
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BUMP_TYPE="${{ inputs.release-type }}"
          else
            BUMP_TYPE=$(determine_bump_type "$COMMIT_MSG" "$CURRENT_VERSION")
          fi
        fi
        
        # Proceed with version bumping if we have a bump type (from custom pattern or standard logic)
        if [ "$CUSTOM_PATTERN_MATCHED" = "false" ]; then
          echo "No custom pattern matched, using standard logic"
        fi
        
        echo "Current version: $CURRENT_VERSION"
        echo "Determined bump type: $BUMP_TYPE"
        
        if [ "$BUMP_TYPE" = "none" ]; then
          echo "No version bump needed"
          exit 0
        fi
        
        echo "Attempting to bump version from $CURRENT_VERSION using bump type: $BUMP_TYPE"
        case "$BUMP_TYPE" in
          premajor|preminor|prepatch|prerelease)
            echo "Running: npm version $BUMP_TYPE --preid=beta --no-git-tag-version"
            if ! npm version "$BUMP_TYPE" --preid=beta --no-git-tag-version; then
              echo "ERROR: Failed to bump version with npm version command"
              exit 1
            fi ;;
          *)
            echo "Running: npm version $BUMP_TYPE --no-git-tag-version"
            if ! npm version "$BUMP_TYPE" --no-git-tag-version; then
              echo "ERROR: Failed to bump version with npm version command"
              exit 1
            fi ;;
        esac
        
        NEW_VERSION=$(node -p "require('./package.json').version")
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"

    - name: Generate changelog
      if: ${{ inputs.enable-release == 'true' && inputs.release-create-changelog == 'true' && steps.version.outputs.version }}
      id: changelog
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        generate_changelog() {
          local new_version="$1"
          local prev_tag="$2"
          
          cat << EOF
        # Changelog for v${new_version}
        
        ## What's Changed
        
        EOF
          
          if [ -z "$prev_tag" ]; then
            echo "Initial release"
            echo ""
            
            # Categorize commits for initial release too
            declare -A categories=(
              ["feat"]="New Features"
              ["fix"]="Bug Fixes" 
              ["perf"]="Performance Improvements"
              ["refactor"]="Code Refactoring"
              ["docs"]="Documentation"
              ["test"]="Testing"
              ["chore"]="Maintenance"
              ["ci"]="CI/CD"
              ["style"]="Code Style"
            )
            
            local has_categorized=false
            for category in feat fix perf refactor docs test chore ci style; do
              local changes=$(git log --pretty=format:"%s (%h)" | \
                grep "^${category}[:(]" | \
                sed "s/^${category}[:(][^):]*[):] */- /" | head -10)
              
              if [ -n "$changes" ]; then
                echo "### ${categories[$category]}"
                echo ""
                echo "$changes"
                echo ""
                has_categorized=true
              fi
            done
            
            # Show other changes if no categorized commits found
            if [ "$has_categorized" = "false" ]; then
              echo "### Changes"
              echo ""
              git log --pretty=format:"- %s (%h)" | head -10
              echo ""
            fi
          else
            declare -A categories=(
              ["feat"]="New Features"
              ["fix"]="Bug Fixes" 
              ["perf"]="Performance Improvements"
              ["refactor"]="Code Refactoring"
              ["docs"]="Documentation"
              ["test"]="Testing"
              ["chore"]="Maintenance"
              ["ci"]="CI/CD"
              ["style"]="Code Style"
            )
            
            for category in feat fix perf refactor docs test chore ci style; do
              local changes=$(git log "${prev_tag}..HEAD" --pretty=format:"%s (%h)" | \
                grep "^${category}[:(]" | \
                sed "s/^${category}[:(][^):]*[):] */- /")
              
              if [ -n "$changes" ]; then
                echo "### ${categories[$category]}"
                echo ""
                echo "$changes"
                echo ""
              fi
            done
            
            local other_changes=$(git log "${prev_tag}..HEAD" --pretty=format:"%s (%h)" | \
              grep -v "^feat[:(]\|^fix[:(]\|^perf[:(]\|^refactor[:(]\|^docs[:(]\|^test[:(]\|^chore[:(]\|^ci[:(]\|^style[:(]" | \
              sed "s/^/- /")
            
            if [ -n "$other_changes" ]; then
              echo "### Other Changes"
              echo ""
              echo "$other_changes"
              echo ""
            fi
          fi
          
          echo ""
          if [ -n "$prev_tag" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${prev_tag}...v${new_version}"
          else
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/v${new_version}"
          fi
        }
        
        PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        NEW_VERSION="${{ steps.version.outputs.version }}"
        
        CHANGELOG_CONTENT=$(generate_changelog "$NEW_VERSION" "$PREV_TAG")
        
        if [ -f CHANGELOG.md ]; then
          echo -e "${CHANGELOG_CONTENT}\n\n$(cat CHANGELOG.md)" > CHANGELOG_NEW.md
          mv CHANGELOG_NEW.md CHANGELOG.md
        else
          echo "$CHANGELOG_CONTENT" > CHANGELOG.md
        fi
        
        echo "$CHANGELOG_CONTENT" >> $GITHUB_STEP_SUMMARY

    - name: Commit changes
      if: ${{ inputs.enable-release == 'true' && inputs.release-bump-version == 'true' && steps.version.outputs.version }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Add package.json and appropriate lock file
        git add package.json
        if [ "${{ inputs.package-manager }}" = "npm" ] && [ -f package-lock.json ]; then
          git add package-lock.json
        elif [ "${{ inputs.package-manager }}" = "pnpm" ] && [ -f pnpm-lock.yaml ]; then
          git add pnpm-lock.yaml
        fi
        if [ -f CHANGELOG.md ] && [ "${{ inputs.release-create-changelog }}" = "true" ]; then
          git add CHANGELOG.md
        fi
        git commit -m "chore(release): v${{ steps.version.outputs.version }} [skip ci]" || echo "No changes to commit"

    - name: Push changes
      if: ${{ inputs.enable-release == 'true' && inputs.release-bump-version == 'true' && steps.version.outputs.version }}
      shell: bash
      run: |
        git push origin main

    - name: Check for existing tag/release
      if: ${{ inputs.enable-release == 'true' && steps.version.outputs.version }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        TAG_NAME="v${{ steps.version.outputs.version }}"
        
        # Check if tag already exists
        if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
          echo "Tag $TAG_NAME already exists"
          
          if [ "${{ inputs.release-override-existing }}" = "false" ]; then
            echo "Error: Tag $TAG_NAME already exists. Set release-override-existing to true to replace it."
            exit 1
          else
            echo "Warning: Overriding existing tag $TAG_NAME"
            # Delete existing tag locally and remotely
            git tag -d "$TAG_NAME" 2>/dev/null || true
            git push --delete origin "$TAG_NAME" 2>/dev/null || true
          fi
        fi
        
        # Check if release already exists
        if gh release view "$TAG_NAME" >/dev/null 2>&1; then
          echo "Release $TAG_NAME already exists"
          
          if [ "${{ inputs.release-override-existing }}" = "false" ]; then
            echo "Error: Release $TAG_NAME already exists. Set release-override-existing to true to replace it."
            exit 1
          else
            echo "Warning: Overriding existing release $TAG_NAME"
            # Delete existing release
            gh release delete "$TAG_NAME" --yes
          fi
        fi

    - name: Create GitHub Release
      if: ${{ inputs.enable-release == 'true' && steps.version.outputs.version }}
      id: release
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        RELEASE_NOTES=""
        if [ "${{ inputs.release-create-changelog }}" = "true" ] && [ -f CHANGELOG.md ]; then
          RELEASE_NOTES=$(head -50 CHANGELOG.md)
        fi
        
        # Create the release (compatible with older gh CLI versions)
        if [[ "${{ steps.version.outputs.version }}" == *"-"* ]]; then
          gh release create v${{ steps.version.outputs.version }} \
            --title "v${{ steps.version.outputs.version }}" \
            --notes "${RELEASE_NOTES}" \
            --prerelease
        else
          gh release create v${{ steps.version.outputs.version }} \
            --title "v${{ steps.version.outputs.version }}" \
            --notes "${RELEASE_NOTES}"
        fi
        
        # Generate release URL
        RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }}"
        echo "url=$RELEASE_URL" >> $GITHUB_OUTPUT

    - name: Create Git Tag
      if: ${{ inputs.enable-release == 'true' && inputs.release-create-tag == 'true' && steps.version.outputs.version }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        TAG_NAME="v${{ steps.version.outputs.version }}"
        echo "Creating git tag $TAG_NAME"
        
        # Check if tag was already created by gh release create
        if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
          echo "Tag $TAG_NAME already exists (likely created by gh release create), skipping tag creation"
        else
          # Create tag if it doesn't exist
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
          echo "Git tag $TAG_NAME created and pushed"
        fi

    - name: Publish to NPM
      if: ${{ inputs.enable-release == 'true' && inputs.release-publish-package == 'true' && steps.version.outputs.version }}
      id: publish
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        NODE_AUTH_TOKEN: ${{ inputs.github-token }}
      run: |
        echo "Debug: Publishing package..."
        echo "Registry URL: ${{ inputs.registry-url }}"
        echo "Registry Scope: ${{ inputs.registry-scope }}"
        echo "Repository Name: ${{ github.event.repository.name }}"
        echo "Repository Owner: ${{ github.repository_owner }}"
        echo "Full Repository: ${{ github.repository }}"
        
        # Check package.json name
        PACKAGE_NAME=$(node -p "require('./package.json').name" 2>/dev/null || echo "not-found")
        echo "Package name from package.json: $PACKAGE_NAME"
        
        # Publish using appropriate package manager
        if [ "${{ inputs.package-manager }}" = "npm" ]; then
          npm publish
        else
          pnpm publish --no-git-checks
        fi
        
        # Determine package name (from input or package.json)
        if [ -n "${{ inputs.package-name }}" ]; then
          PACKAGE_NAME="${{ inputs.package-name }}"
          echo "Using package name from input: $PACKAGE_NAME"
        else
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          echo "Using package name from package.json: $PACKAGE_NAME"
        fi
        
        # Generate package URL based on package name
        if [[ "$PACKAGE_NAME" == @* ]]; then
          # Package is already scoped, use as-is
          PACKAGE_URL="${{ inputs.registry-url }}/$PACKAGE_NAME"
        else
          # Package is not scoped, construct with registry scope
          PACKAGE_URL="${{ inputs.registry-url }}/@${{ inputs.registry-scope }}/$PACKAGE_NAME"
        fi
        echo "Generated package URL: $PACKAGE_URL"
        echo "url=$PACKAGE_URL" >> $GITHUB_OUTPUT

    - name: Comment on issues
      if: ${{ inputs.enable-release == 'true' && inputs.release-comment-issues == 'true' && steps.version.outputs.version }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        ISSUES=$(git log ${PREV_TAG}..HEAD --pretty=format:"%B" | grep -oE '#[0-9]+' | sort -u)
        
        for ISSUE in $ISSUES; do
          ISSUE_NUM=${ISSUE#"#"}
          gh api repos/${{ github.repository }}/issues/${ISSUE_NUM}/comments \
            --method POST \
            --field body="This issue has been addressed in release [v${{ steps.version.outputs.version }}](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }})"
        done